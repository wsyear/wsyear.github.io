<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>题解 CF1591D 【Yet Another Sorting Problem】</title>
    <link href="/2021/12/15/%E9%A2%98%E8%A7%A3%20CF1591D%20%E3%80%90Yet%20Another%20Sorting%20Problem%E3%80%91/"/>
    <url>/2021/12/15/%E9%A2%98%E8%A7%A3%20CF1591D%20%E3%80%90Yet%20Another%20Sorting%20Problem%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p><strong>前言：这题思维难度还不错吧，不过有小哥在评论区说是盗题的/doge</strong></p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>给你一个长度为 $n$ 的序列 $a$，$\forall i$ 满足 $1\le i \le n$，都有 $1\le a_i\le n$，但注意 $a$ 中可能会有重复的元素。</p><p>现在，给定一种swap操作：</p><ul><li>选定三个不同的数 $i,j,k$ 满足 $1\le i,j,k \le n$，操作后 $a_i,a_j,a_k$ 分别变为 $a_k,a_i,a_j$。</li></ul><p>问你这个序列 $a$ 能否通过若干次swap操作后变成一个非递减序列。</p><h2 id="思路简述"><a href="#思路简述" class="headerlink" title="思路简述"></a>思路简述</h2><p>首先要分类讨论。</p><p>如果有至少两个数的数值相同，那么答案一定是<code>YES</code>。</p><p>假设我们要交换两个数 $b$ 与 $c$，相同的数的数值为 $a$。那么我们可以进行以下操作（原序列为 $[a,a,b,c]$）：</p><p>$[a,a,b,c]\to[\underline b,\underline a,\underline a,c]\to[b,\underline c,\underline a,\underline a]\to[b,\underline a,\underline c,\underline a]\to[\underline a,\underline b,c,\underline a]\to[\underline a,\underline a,c,\underline b]$</p><p>这样就完成了 $b$ 与 $c$ 之间的位置交换。有了这样的操作以后，我们就可以把新的swap操作看成普通的交换两个元素的操作。至于两个相同元素的位置，我们可以先将其他的排成某种特定的顺序，最后再与他们交换以达到归位的效果。因此答案一定为<code>YES</code>。</p><p>如果每个数都不相同，那么这个序列就成了 $1$ 到 $n$ 的全排列。我们可以处理出每个循环节的长度。</p><p>在尝试几次以后，我们发现，进行一次swap操作，相当于：</p><ul><li><p>将两个长度为 $a$ 与 $b$ 的循环节合并为一个长度为 $a+b-1$ 的新的循环节；或将一个拆分为两个。</p></li><li><p>将三个长度分别为 $a$，$b$ 与 $c$ 的循环节合并成一个长度为 $a+b+c$ 的循环节；或将一个拆分三个。</p></li><li><p>将某个单独的循环节长度加 $2$ 或减 $2$。</p></li></ul><p>现在我们可以进行合并和分解循环节的操作。如果最后循环节的长度是奇数，那么答案就是<code>YES</code>，否则为<code>NO</code>。</p><p>蒟蒻的语文水平贼差，看不懂是正常的，不过，看代码应该能看懂把qwq。。</p><h2 id="蒟蒻代码"><a href="#蒟蒻代码" class="headerlink" title="蒟蒻代码"></a>蒟蒻代码</h2><p><strong>Talk is cheap, show me the code.</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n,a[<span class="hljs-number">500010</span>],cnt[<span class="hljs-number">500010</span>];<br><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">500010</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) cnt[i]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) a[i]=<span class="hljs-built_in">read</span>(),cnt[a[i]]++;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(cnt[i]&gt;=<span class="hljs-number">2</span>)&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) vis[i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> sum=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!vis[i])&#123;<br><span class="hljs-keyword">int</span> x=i,cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(!vis[x]) vis[x]=<span class="hljs-number">1</span>,x=a[x],cnt++;<br>sum+=cnt<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(sum&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 CF1608D 【Dominoes】</title>
    <link href="/2021/12/13/%E9%A2%98%E8%A7%A3%20CF1608D%20%E3%80%90Dominoes%E3%80%91/"/>
    <url>/2021/12/13/%E9%A2%98%E8%A7%A3%20CF1608D%20%E3%80%90Dominoes%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p><del><strong>前言：这可能是蒟蒻能写出来的计数题的难度上限了qwq</strong></del></p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>让你给 $n$ 个多米诺骨牌黑白染色，每个骨牌有两个格子。</p><p>若将这 $n$ 个骨牌重新排列后<strong>至少存在</strong>一种方案，使得 $\forall i$，第i个骨牌右边格子颜色与第 $(i\mod n)+1$ 个骨牌左边颜色不同，则这种染色方法合法。</p><p>问你有几种<strong>合法</strong>的染色方案。</p><p><del>可能不是讲得很清楚，看不懂去看英文题面吧（逃</del></p><h2 id="思路简述"><a href="#思路简述" class="headerlink" title="思路简述"></a>思路简述</h2><p>首先通过观察，我们发现对于任意一种合法的染色方案：</p><ul><li><p><code>BB</code>和<code>WW</code>这两种颜色类型的骨牌数量一定是相等的。</p></li><li><p>如果有<code>BW</code>和<code>WB</code>种类的骨牌，那么至少要有 $1$ 个<code>BB</code>和 $1$ 个<code>WW</code>类型的骨牌。</p></li></ul><p>而且这两个条件是合法染色方案的充要条件。接下来是对以上两个结论的感性证明：</p><ul><li>对于第一条结论，我们可以认为<code>WW</code>与<code>BB</code>为骨牌序列的<strong>转折点</strong>，因为一个连续的<code>WB</code>序列后面跟上一个<code>WW</code>序列后，后面就会变成连续的<code>BW</code>序列。因为所有的序列构成一个环后始终符合条件。所以，我们可以清晰地看到，两种转折点地数量一定相等。</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1xc0lu9x.png"></p><ul><li><p>可以来张图片：我们认为<code>BW</code>的连续序列为橙色线段，<code>WB</code>的连续序列为绿色线段。那么黑点表示<code>BB</code>，作为<code>BW</code>与<code>WB</code>的转折点；灰点表示<code>WW</code>，作为<code>WB</code>与<code>BW</code>的转折点。因为最后环上一定是橙绿线段首尾衔接的，所以橙线段与绿线段数量相等，黑点与灰点数量相等，所以<code>BB</code>与<code>WW</code>数量也就一样多了。</p></li><li><p>对于第二条结论，如果<code>BW</code>与<code>WB</code>都存在，那么必定存在至少一个转折点，所以必定有<code>WW</code>与<code>BB</code>。</p></li></ul><p><strong>性质观察完了，我们开始想想应该怎么算。</strong></p><p>我们先定义：出现在一个骨牌左边的<code>W</code>为<code>W1</code>，右边的<code>W</code>为<code>W2</code>。同理，有<code>B1</code>，<code>B2</code>，<code>Q1</code>与<code>Q2</code>（<code>Q</code>表示<code>?</code>）。假设<code>B1</code>有 $i$ 个，<code>W2</code>也有 $i$ 个，那么可得<code>B2</code>有 $n-i$ 个，<code>W1</code>也有 $n-i$ 个。枚举这个 $i$ 即可算出<strong>大致合法</strong>的有几个，公式为：</p><p>$$\sum\limits_{i=1}^n C_{Q1}^{i-B1}\times C_{Q2}^{n-i-B2}$$</p><p>但是这并不符合我们推出来的结论，我们想想他们之间的差距在哪里。</p><p>经过观察，我们发现，不符合第二条结论的情况会被数进去。因此要减去有<code>BW</code>与<code>WB</code>但是没有<code>WW</code>与<code>BB</code>的情况。我们可以先减去没有<code>WW</code>与<code>BB</code>的情况，再加回只有<code>WB</code>与<code>BW</code>的情况。</p><p>要算没有<code>BB</code>与<code>WW</code>的情况，由于<code>BB</code>和<code>WW</code>的数量一定相等，所以如果已经有<code>BB</code>或<code>WW</code>了，那么就不用减。减的数量为：</p><p>$$2^{??}$$</p><p>因为只有<code>??</code>可以构造出<code>BW</code>与<code>WB</code>两种情况，其他的<code>W?</code>,<code>?W</code>,<code>?B</code>,<code>B?</code>都只能构造出一种不是<code>BB</code>且不是<code>WW</code>的情况，相当于乘了 $1$，等于没乘。</p><p>最后，还要算只有<code>WB</code>与<code>BW</code>的情况，那么有两种情况会加 $1$：</p><ul><li><p><code>W1</code>与<code>B2</code>都是 $0$。</p></li><li><p><code>B1</code>与<code>W2</code>都是 $0$。</p></li></ul><p>好了，总算算完了。所以最后的公式是：</p><p>$$\sum\limits_{i=1}^n C_{Q1}^{i-B1}\times C_{Q2}^{n-i-B2}-[bb=0&amp;ww=0]\times 2^{??}+[w1=0&amp;b2=0]+[b1=0&amp;w2=0]$$</p><h2 id="蒟蒻代码"><a href="#蒟蒻代码" class="headerlink" title="蒟蒻代码"></a>蒟蒻代码</h2><p><strong>Talk is cheap, show me the code.</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 998244353</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><br><span class="hljs-keyword">int</span> n,cnt[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br>string s;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">char</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x==<span class="hljs-string">&#x27;?&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x==<span class="hljs-string">&#x27;W&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x==<span class="hljs-string">&#x27;B&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<span class="hljs-comment">//将字符转化为数字，方便统计</span><br><span class="hljs-keyword">int</span> inv[<span class="hljs-number">100010</span>],fact[<span class="hljs-number">100010</span>],ifact[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">2</span>,<span class="hljs-number">100000</span>) inv[i]=(mod-mod/i)*inv[mod%i]%mod;<br>fact[<span class="hljs-number">0</span>]=ifact[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">100000</span>) fact[i]=fact[i<span class="hljs-number">-1</span>]*i%mod;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">100000</span>) ifact[i]=ifact[i<span class="hljs-number">-1</span>]*inv[i]%mod;<br>&#125;<span class="hljs-comment">//阶乘预处理，用来算组合数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span></span>&#123;<br><span class="hljs-keyword">if</span>(n&lt;m||m&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> fact[n]*ifact[m]%mod*ifact[n-m]%mod;<br>&#125;<span class="hljs-comment">//组合数的简单计算</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> qwq=<span class="hljs-built_in">qpow</span>(a,p/<span class="hljs-number">2</span>);<br><span class="hljs-keyword">if</span>(p%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> qwq*qwq%mod*a%mod;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> qwq*qwq%mod;<br>&#125;<span class="hljs-comment">//快速幂模板</span><br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>cin&gt;&gt;s;<br>cnt[<span class="hljs-built_in">change</span>(s[<span class="hljs-number">0</span>])][<span class="hljs-built_in">change</span>(s[<span class="hljs-number">1</span>])]++;<span class="hljs-comment">//统计各种类型的数量</span><br>&#125;<br><span class="hljs-keyword">int</span> w1=cnt[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+cnt[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+cnt[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">//算w1</span><br><span class="hljs-keyword">int</span> b1=cnt[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]+cnt[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]+cnt[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">//算b1</span><br><span class="hljs-keyword">int</span> w2=cnt[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+cnt[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+cnt[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<span class="hljs-comment">//算w2</span><br><span class="hljs-keyword">int</span> b2=cnt[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]+cnt[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]+cnt[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">//算b2</span><br><span class="hljs-keyword">int</span> q1=n-w1-b1,q2=n-w2-b2;<span class="hljs-comment">//算q1和q2</span><br><span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">0</span>,n) ans=(ans+<span class="hljs-built_in">C</span>(q1,i-b1)*<span class="hljs-built_in">C</span>(q2,n-i-b2))%mod;<span class="hljs-comment">//先算第一个sigma</span><br><span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>&amp;&amp;cnt[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]==<span class="hljs-number">0</span>) ans-=<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,cnt[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<span class="hljs-comment">//减去没有WW和BB的</span><br><span class="hljs-keyword">if</span>(w1==<span class="hljs-number">0</span>&amp;&amp;b2==<span class="hljs-number">0</span>) ans++;<br><span class="hljs-keyword">if</span>(b1==<span class="hljs-number">0</span>&amp;&amp;w2==<span class="hljs-number">0</span>) ans++;<span class="hljs-comment">//加回只有BW和WB的</span><br>cout&lt;&lt;ans&lt;&lt;endl;<span class="hljs-comment">//Happy Ending</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 CF1608B 【Build the Permutation】</title>
    <link href="/2021/12/13/%E9%A2%98%E8%A7%A3%20CF1608B%20%E3%80%90Build%20the%20Permutation%E3%80%91/"/>
    <url>/2021/12/13/%E9%A2%98%E8%A7%A3%20CF1608B%20%E3%80%90Build%20the%20Permutation%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p><del><strong>前言：这道题这个蒟蒻在考场上写了10分钟。</strong></del></p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>给你三个数 $n$,$a$,$b$，要你构造一个长度为 $n$ 的序列，要求这个序列有 $a$ 个单峰与 $b$ 个单谷。</p><p>单峰的定义是：称 $i$ 为单峰当且仅当满足 $1\le i \le n-1$ 且 $q_{i-1}<q_i>q_{i+1}$。</p><p>单谷的定义是：称 $i$ 为单峰当且仅当满足 $1\le i \le n-1$ 且 $q_{i-1}&gt;q_i&lt;q_{i+1}$。</p><p>其中 $q$ 为你构造的序列。如果无法构造出这样的序列，那么输出<code>-1</code>。</p><h2 id="思路简述"><a href="#思路简述" class="headerlink" title="思路简述"></a>思路简述</h2><p>首先很容易观察出一个性质：</p><ul><li><p>任意两个单峰之间都有且只有一个单谷。</p></li><li><p>任意两个单谷之间都有且只有一个单峰。</p></li></ul><p>因为任意两个单峰之间一定只有一个转折点，而这个转折点就是单谷。第二条同理。</p><p>因此，我们发现 $|a-b|\le 1$。还要注意单峰与单谷的总和最多只有 $n-2$ 个，所以还要满足 $a+b\le n-2$。</p><p>因此我们得出了答案为<code>-1</code>的条件：$|a-b|&gt;1$ 或 $a+b&gt;n-2 $。</p><p>然后就是简单的分类讨论了，我们称单峰为 $U$，单谷为$D$。</p><ul><li><p>$a=b+1$：我们从第二个数开始以 $UDU\dots DU$ 的顺序填充数组。</p></li><li><p>$a=b$：我们从第二个数开始以 $UDUD\dots UD$ 的顺序填充数组。</p></li><li><p>$a=b-1$：我们从第二个数开始以 $DUD\dots UD$ 的顺序填充数组。</p></li></ul><p>在后面就直接将剩下的数从小到大塞进去就好了，这样就不会在后面再产生单峰或单谷了。</p><h2 id="蒟蒻代码"><a href="#蒟蒻代码" class="headerlink" title="蒟蒻代码"></a>蒟蒻代码</h2><p><strong>Talk is cheap, show me the code.</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n,a,b;<br><span class="hljs-keyword">int</span> ans[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>n=<span class="hljs-built_in">read</span>(),a=<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">if</span>(a+b&gt;n<span class="hljs-number">-2</span>||<span class="hljs-built_in">abs</span>(a-b)&gt;<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(a&gt;b)&#123;<br><span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=n;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>*a)&#123;<br><span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) ans[i]=l++;<br><span class="hljs-keyword">else</span> ans[i]=r--; <br>&#125;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">2</span>*a+<span class="hljs-number">1</span>,n) ans[i]=r--;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a&lt;b)&#123;<br><span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=n;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>*b)&#123;<br><span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) ans[i]=r--;<br><span class="hljs-keyword">else</span> ans[i]=l++;<br>&#125;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">2</span>*b+<span class="hljs-number">1</span>,n) ans[i]=l++;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==b)&#123;<br><span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=n;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>*a+<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) ans[i]=l++;<br><span class="hljs-keyword">else</span> ans[i]=r--;<br>&#125;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">2</span>*a+<span class="hljs-number">2</span>,n) ans[i]=l++;<br>&#125;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i]);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><del>这代码这么丑，还有人要看？</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 CF1608A 【Find Array】</title>
    <link href="/2021/12/13/%E9%A2%98%E8%A7%A3%20CF1608A%20%E3%80%90Find%20Array%E3%80%91/"/>
    <url>/2021/12/13/%E9%A2%98%E8%A7%A3%20CF1608A%20%E3%80%90Find%20Array%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>构造一个长度为 $n$ 的递增序列，要求每一个数都不是前一个数的倍数。</p><h2 id="思路简述"><a href="#思路简述" class="headerlink" title="思路简述"></a>思路简述</h2><p>很好想的一道题，我们知道：</p><blockquote><p>$\forall i$ 满足 $i\ge 2$ 且 $i\in \mathbb{N}$，有 $i+1\equiv 1 \pmod i$ 。</p></blockquote><p>所以，我们只要输出 $2,3,4,\dots,n+1$ 即可。</p><h2 id="蒟蒻代码"><a href="#蒟蒻代码" class="headerlink" title="蒟蒻代码"></a>蒟蒻代码</h2><p><strong>Talk is cheap, show me the code.</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n,a[<span class="hljs-number">1010</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>a[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">2</span>,<span class="hljs-number">1000</span>) a[i]=a[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">work</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p><del>这代码有什么好看的。。。</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 CF1608C 【Game Master】</title>
    <link href="/2021/12/13/%E9%A2%98%E8%A7%A3%20CF1608C%20%E3%80%90Game%20Master%E3%80%91/"/>
    <url>/2021/12/13/%E9%A2%98%E8%A7%A3%20CF1608C%20%E3%80%90Game%20Master%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p><del><strong>前言：我想再骂一下这场比赛的fst。</strong></del></p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>有 $n$ 个人在玩游戏，第 $i$ 个人有两个能力值 $a_i$ 与 $b_i$。如果第 $i$ 个玩家的任意一个能力值大于第 $j$ 个玩家，则称第 $i$ 个玩家可战胜第 $j$ 个玩家。现在要进行 $n-1$ 场淘汰赛，问每个玩家是否有可能成为总冠军。输出一个长度为 $n$ 的01串表示答案。</p><p>数据范围 $n\le 10^5$。</p><h2 id="思路简述"><a href="#思路简述" class="headerlink" title="思路简述"></a>思路简述</h2><p>看着就像要把这些玩家放到无向图上，然后跑tarjan缩点。</p><p>但是，这里介绍一种贪心的方案。</p><p>首先先按照 $a$ 值的大小将玩家排序。然后求出排序后的序列的后缀 $b$ 最大值，称 $suf_i$。</p><p>从左往右扫的时候，记录一下前缀可能成为冠军的玩家的 $b$ 的最小值，称 $pre_i$。</p><p>初始排序后的第一个人肯定能成为冠军，直接用 $a$ 值滥杀。</p><p>对于后面的每一个人，如果$suf_i&gt;pre_i$，则他可能成为冠军，因为他可以先用 $a$ 杀掉他后面 $b$ 值最大的人，那个人的 $b$ 值又可以杀掉前面的某个冠军，那么他也就能成为冠军了。</p><p>对于 $pre$ 值：</p><ul><li><p>如果 $ans_i=0$，则$pre_{i+1}=pre_i$；</p></li><li><p>否则 $pre_{i+1}=\max(pre_i,b_i)$。</p></li></ul><p>注意不能对所有的人都进行取 $\max$，因为后面的人杀掉一个前面无法成为冠军的人是没用的。<del>（考场上就死在这里）</del></p><p>正确性的证明感性理解一下就好qwq。</p><h2 id="蒟蒻代码"><a href="#蒟蒻代码" class="headerlink" title="蒟蒻代码"></a>蒟蒻代码</h2><p><strong>Talk is cheap, show me the code.</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br><span class="hljs-keyword">int</span> id,a,b;<br>&#125;a[<span class="hljs-number">100010</span>];<br><span class="hljs-keyword">int</span> ans[<span class="hljs-number">100010</span>],M[<span class="hljs-number">100010</span>],Md[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(node x,node y)</span></span>&#123;<br><span class="hljs-keyword">return</span> x.a&gt;y.a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) a[i].id=i,a[i].a=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) a[i].b=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp1);<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) ans[i]=<span class="hljs-number">0</span>;<br>M[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">Rof</span>(i,n,<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(a[i].b&gt;M[i+<span class="hljs-number">1</span>]) M[i]=a[i].b,Md[i]=i;<br><span class="hljs-keyword">else</span> M[i]=M[i+<span class="hljs-number">1</span>],Md[i]=Md[i+<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">int</span> mn=<span class="hljs-number">1000000007</span>;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n)&#123;<br><span class="hljs-keyword">if</span>(M[i]&gt;mn||i==<span class="hljs-number">1</span>)&#123;<br>ans[a[i].id]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">ckmn</span>(mn,a[i].b);<br>&#125;<br>&#125;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans[i]);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> T=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">work</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 CF1609D 【Social Network】</title>
    <link href="/2021/12/02/%E9%A2%98%E8%A7%A3%20CF1609D%20%E3%80%90Social%20Network%E3%80%91/"/>
    <url>/2021/12/02/%E9%A2%98%E8%A7%A3%20CF1609D%20%E3%80%90Social%20Network%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p><del><strong>前言：又是一道比C还水的CF题</strong></del></p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>有 $d$ 个约束条件，每个约束条件都表示为 $(u,v)$ 的形式，表示 $u$ 号节点与 $v$ 号节点需要在同一个连通块中。</p><p>$\forall i\in [1,d]$ ，求在满足 $[1,i]$ 的规定的前提下恰好连 $i$ 条边的无向图最大连通块的大小最大可能是多少。</p><h2 id="蒟蒻思路"><a href="#蒟蒻思路" class="headerlink" title="蒟蒻思路"></a>蒟蒻思路</h2><p>这题思路很好想，<del>可能是蒟蒻这场比赛切地最快的一题了</del>。</p><p>首先肯定是并查集来维护关系，还要记录一个 $R$ 表示满足前面所有条件的情况下，剩下最多还能连多少条边。</p><p>当我们要认定 $u$ 与 $v$ 在同一个连通块中时，可以先判断一下他们是否已经在连通块中了。</p><ul><li><p>如果在同一个连通块中，那么直接将 $R$ 增加 $1$。</p></li><li><p>如果不是在同一个连通块中，那么将连通块合并。注意合并的时候还要记录一下每个连通块的 $size$：如果这个点是一个连通块的根，那么它的 $size$ 就是连通块大小；否则 $size$ 就是 $0$。</p></li></ul><p>每次操作后，都将 $size$ 数组从大到小拍一下序，求出前 $R+1$（$R$ 条边可以构成 $R+1$ 个连通块）大的值的和减一（自己认识自己不算）即可。</p><h2 id="蒟蒻代码"><a href="#蒟蒻代码" class="headerlink" title="蒟蒻代码"></a>蒟蒻代码</h2><p><strong>Talk is cheap, show me the code!</strong></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n,d;<br><span class="hljs-keyword">int</span> x[<span class="hljs-number">1010</span>],y[<span class="hljs-number">1010</span>];<br><span class="hljs-keyword">int</span> fa[<span class="hljs-number">1010</span>],sz[<span class="hljs-number">1010</span>];<br><span class="hljs-keyword">int</span> rk[<span class="hljs-number">1010</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> fa[x]==x?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> fx=<span class="hljs-built_in">find</span>(x),fy=<span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(fx!=fy)&#123;<br>fa[fy]=fx;<br>sz[fx]+=sz[fy];<br>sz[fy]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>n=<span class="hljs-built_in">read</span>(),d=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i,sz[i]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,d) x[i]=<span class="hljs-built_in">read</span>(),y[i]=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">int</span> rest=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,d)&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">merge</span>(x[i],y[i])) rest++;<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) rk[i]=sz[i];<br><span class="hljs-built_in">sort</span>(rk+<span class="hljs-number">1</span>,rk+n+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">int</span> kk=rest+<span class="hljs-number">1</span>,pos=n,ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(kk--)&#123;<br>ans+=rk[pos--];<br>&#125;<br>cout&lt;&lt;ans<span class="hljs-number">-1</span>&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 P7914 【[CSP-S 2021] 括号序列】</title>
    <link href="/2021/11/01/%E9%A2%98%E8%A7%A3%20P7914%20%E3%80%90%5BCSP-S%202021%5D%20%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%E3%80%91/"/>
    <url>/2021/11/01/%E9%A2%98%E8%A7%A3%20P7914%20%E3%80%90%5BCSP-S%202021%5D%20%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p>一篇不需要处理算重的题解</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del>作者是一个考场上没推出来的蒟蒻</del></p><p>看了一下现在已经有的3篇题解，都是要用两个dp数组或者要复杂地处理算重方案的，但是蒟蒻太菜，不想推这么复杂的，于是在赛后参考了@<a href="https://www.luogu.com.cn/user/34225">wdssean</a>的思路，写了这一篇题解。个人觉得自己的思路还是蛮清晰的。</p><h2 id="思路简述"><a href="#思路简述" class="headerlink" title="思路简述"></a>思路简述</h2><p>首先肯定是区间dp，令 $dp_{i,j}$ 表示从位置 $i$ 到位置 $j$ 一共的合法序列总情况数量。</p><p>但是不同的形态可能会有不同的转移，如：<code>(S)</code>这种只能从<code>S</code>转移过来等等。所以只开两维的dp状态必然是不够的。</p><p>直接将方法吧。将两位的dp扩充为三维，第三位表示不同的形态种类，dp状态就变成了 $dp_{i,j,[0,5]}$。没种状态表示：</p><ul><li><p>$dp_{i,j,0}$: 形态如<code>***...*</code>的括号序列（即全部是<code>*</code>）。</p></li><li><p>$dp_{i,j,1}$: 形态如<code>(...)</code>的括号序列（即左右直接被括号包裹且最左边括号与最右边的括号相互匹配）。</p></li><li><p>$dp_{i,j,2}$: 形态如<code>(...)**(...)***</code>的括号序列（即左边以括号序列开头，右边以<code>*</code>结尾）。</p></li><li><p>$dp_{i,j,3}$: 形态如<code>(...)***(...)*(...)</code>的括号序列（即左边以括号序列开头，右边以括号序列结尾，注意：第2种形态也属于这种形态）。</p></li><li><p>$dp_{i,j,4}$: 形态如<code>***(...)**(...)</code>的括号序列（即左边以<code>*</code>开头，右边以括号序列结尾）。</p></li><li><p>$dp_{i,j,5}$: 形态如<code>***(...)**(...)**</code>的括号序列（即左边以<code>*</code>开头，右边以<code>*</code>结尾，注意：第1种形态也属于这种形态）。</p></li></ul><p>设定完状态以后，转移就直接出来了，注意：为了防止连续超过 $k$ 个<code>*</code>一起出现，转移的时候不能把两段<code>*</code>拼接起来，在状态1的时候暴力判断一下两端的距离是否是 $\le k$ 的，是的才能转移。</p><p>作为一篇题解，转移虽然很简单，但是好得说一下吧。</p><ul><li><p>$dp_{l,r,0}$（直接特判）</p></li><li><ul><li>没什么好解释的</li></ul></li><li><p>$dp_{l,r,1}=(dp_{l+1,r-1,0}+dp_{l+1,r-1,2}+dp_{l+1,r-1,3}+dp_{l+1,r-1,4})*compare(l,r)$</p></li><li><ul><li>$compare(i,j)$ 表示第 $i$ 位与第 $j$ 位能否配对成括号，能则为 $1$，否则为 $0$。</li></ul></li><li><ul><li>加括号时，里面可以是全<code>*</code>，可以是有一边是<code>*</code>，也可以是两边都不是<code>*</code>，唯独不能两边都是<code>*</code>且中间有括号序列。</li></ul></li><li><p>$dp_{l,r,2}=\sum\limits_{i=l}^{r-1} dp_{l,i,3}\times dp_{i+1,r,0}$</p></li><li><ul><li>左边以括号序列开头且以括号序列结尾的是第3种，右边接一串<code>*</code>，是第0种。</li></ul></li><li><p>$dp_{l,r,3}=\sum\limits_{i=l}^{r-1} (dp_{l,i,2}+dp_{l,i,3})\times dp_{i+1,r,1}+dp_{l,r,1}$</p></li><li><ul><li>左边以括号序列开头，结尾随便，符合的有第2和第3种，右边接一个括号序列，是第1种。</li></ul></li><li><ul><li>记得加上直接一个括号序列的。</li></ul></li><li><p>$dp_{l,r,4}=\sum\limits_{i=l}^{r-1} (dp_{l,i,4}+dp_{l,i,5})\times dp_{i+1,r,1}$</p></li><li><ul><li>左边以<code>*</code>开头，结尾随便，符合的有第4和第5种，右边接一个括号序列，是第1种。</li></ul></li><li><p>$dp_{l,r,5}=\sum\limits_{i=l}^{r-1} dp_{l,i,4}\times dp_{i+1,r,0}+dp_{l,r,0}$</p></li><li><ul><li>左边以<code>*</code>开头，以括号序列结尾，符合的是第4种，右边接一串<code>*</code>，是第0种。</li></ul></li><li><ul><li>记得加上全是<code>*</code>的。</li></ul></li></ul><p>最后，答案必须以括号序列开头，以括号序列结尾，所以直接是 $dp_{1,n,3}$。</p><p>这样，初始状态也就没什么问题了，对于所有的 $i$ 满足 $1\le i \le n$，有 $dp_{i,i-1,0}=1$ 。</p><p>最终时间复杂度 $O(6\times n^3)$ 不到，（后半部分填不满 $n^3$ ）。</p><p>记得开long long，并且取模。</p><h2 id="代码示范"><a href="#代码示范" class="headerlink" title="代码示范"></a>代码示范</h2><p><strong>Talk is cheap, show me the code.</strong></p><p><del>代码挺短的，去掉文件头才28行。</del></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 1000000007</span><br><span class="hljs-keyword">int</span> n,k,dp[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>][<span class="hljs-number">6</span>];<br><span class="hljs-keyword">char</span> s[<span class="hljs-number">510</span>];<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> (s[a]==<span class="hljs-string">&#x27;(&#x27;</span>||s[a]==<span class="hljs-string">&#x27;?&#x27;</span>)&amp;&amp;(s[b]==<span class="hljs-string">&#x27;)&#x27;</span>||s[b]==<span class="hljs-string">&#x27;?&#x27;</span>);&#125;<br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) dp[i][i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">For</span>(len,<span class="hljs-number">1</span>,n)&#123;<br>        <span class="hljs-built_in">For</span>(l,<span class="hljs-number">1</span>,n-len+<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">int</span> r=l+len<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span>(len&lt;=k) dp[l][r][<span class="hljs-number">0</span>]=dp[l][r<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]&amp;&amp;(s[r]==<span class="hljs-string">&#x27;*&#x27;</span>||s[r]==<span class="hljs-string">&#x27;?&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(len&gt;=<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">compare</span>(l,r)) dp[l][r][<span class="hljs-number">1</span>]=(dp[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+dp[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]+dp[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>]+dp[l+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][<span class="hljs-number">4</span>])%mod;<br>                <span class="hljs-built_in">For</span>(i,l,r<span class="hljs-number">-1</span>)&#123;<br>                    dp[l][r][<span class="hljs-number">2</span>]=(dp[l][r][<span class="hljs-number">2</span>]+dp[l][i][<span class="hljs-number">3</span>]*dp[i+<span class="hljs-number">1</span>][r][<span class="hljs-number">0</span>])%mod;<br>                    dp[l][r][<span class="hljs-number">3</span>]=(dp[l][r][<span class="hljs-number">3</span>]+(dp[l][i][<span class="hljs-number">2</span>]+dp[l][i][<span class="hljs-number">3</span>])*dp[i+<span class="hljs-number">1</span>][r][<span class="hljs-number">1</span>])%mod;<br>                    dp[l][r][<span class="hljs-number">4</span>]=(dp[l][r][<span class="hljs-number">4</span>]+(dp[l][i][<span class="hljs-number">4</span>]+dp[l][i][<span class="hljs-number">5</span>])*dp[i+<span class="hljs-number">1</span>][r][<span class="hljs-number">1</span>])%mod;<br>                    dp[l][r][<span class="hljs-number">5</span>]=(dp[l][r][<span class="hljs-number">5</span>]+dp[l][i][<span class="hljs-number">4</span>]*dp[i+<span class="hljs-number">1</span>][r][<span class="hljs-number">0</span>])%mod;<br>                &#125;<br>            &#125;<br>            dp[l][r][<span class="hljs-number">5</span>]=(dp[l][r][<span class="hljs-number">5</span>]+dp[l][r][<span class="hljs-number">0</span>])%mod;<br>            dp[l][r][<span class="hljs-number">3</span>]=(dp[l][r][<span class="hljs-number">3</span>]+dp[l][r][<span class="hljs-number">1</span>])%mod;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,dp[<span class="hljs-number">1</span>][n][<span class="hljs-number">3</span>]);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>都看到这里了，点个赞再走呗qwq。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 CF1583H 【Omkar and Tours】</title>
    <link href="/2021/10/22/%E9%A2%98%E8%A7%A3%20CF1583H%20%E3%80%90Omkar%20and%20Tours%E3%80%91/"/>
    <url>/2021/10/22/%E9%A2%98%E8%A7%A3%20CF1583H%20%E3%80%90Omkar%20and%20Tours%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p><strong>2021.10.27 Update:</strong> 修正了<a href="https://www.luogu.com.cn/user/101868">I_am_Accepted</a>提出的询问。</p><p>一篇来自蒟蒻的题解，不喜误喷，有误请私信。</p><h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>给一幅 $n$ 个点的树，每条边都有两个值：$c$ 与 $t$，其中 $c$ 表示这条边能承载的最大的重量，$t$ 表示通过这条边所需要的花费。每个点也有一个点权 $e$，表示这个点的有趣程度。两个点之间路径的费用是这两个点之间的路径的所有花费中最大的值。现在有 $q$ 组询问，每组询问给出两个值 $v$ 与 $x$，表示有一辆重量为 $v$ 车从 $x$ 点出发，问你这辆车能到达的所有点中有趣程度最大的那个点的有趣程度，以及到达这些点的所有路径中的花费的最大值。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><blockquote><p>想A掉一道复杂的题，先从她的简化版开始分析。</p></blockquote><p>假设所有的点的有趣程度各不相同，那么我们可以用离线的做法。处理询问时，我们可以先将所有的询问按照 $v$ 值排序，<strong>从大到小</strong>还是<strong>从小到大</strong>呢？</p><p>如果我们要从小到大排序的话，我们就要进行删边操作，有没有什么数据结构支持删边维护连通块的呢？似乎没有，有也很难操作。</p><p>因此，我们选择按照 $v$ 值从大到小来排序询问。加边操作只要用一个并查集来维护连通块即可。因此我们可以先将这棵树跑一边dfs，然后用倍增算出 $fa$ 与 $mxval$ 两个数组。其中 $fa[u][i]$ 表示 $u$ 的第 $2^i$ 辈祖先是谁，$mxval[u][i]$ 表示点 $u$ 向上的 $2^i$ 条边中 $t$ 值的最大值。然后就可以 $\log_n$ 求出两点间的距离了（这不是模板吗）。</p><p>然后将所有边按照 $c$ 值排序，一条条加边，当加到的边的 $c$ 值到某一组询问的 $v$ 值时，查询一下就好了。</p><p>加边的时候合并并查集，每个并查集内记录有趣程度最大的值的编号，输出的时候就很方便了，最大值是 $e[u]$ ，距离就是 $x$ 与 $u$ 之间的距离。</p><blockquote><p>想完了简化版的题目，想想简化版的与标准版的有什么区别</p></blockquote><p>我们发现，一个并查集内可能有多个 $e$ 值最大的点。</p><p>做法是在每个并查集中记录两个值：$mxi$ 与 $mx$，其中 $mxi$ 表示这个并查集中 $e$ 值最大的点的编号，$mx$ 表示记录编号的那个点到并查集中其他 $e$ 值最大的点的最大距离。合并的时候比较一下两个并查集中 $e[mxi]$ 的大小。</p><p>假设我们要合并两个并查集的根为 $u$ 与 $v$，并且合并后以 $u$ 作为根。那么分类讨论：</p><ul><li><p>$mxi[u]=mxi[u],mx[u]=mx[u]$，当满足 $e[mxi[u]]&gt;e[mxi[v]]$</p></li><li><p>$mxi[u]=mxi[v],mx[u]=mx[v]$，当满足 $e[mxi[u]]&lt;e[mxi[v]]$</p></li><li><p>$mxi[u]=mxi[u],mx[u]=\max(mx[u],mx[v],getmx(mxi[u],mxi[v]))$，当满足 $e[mxi[u]]=e[mxi[v]]$</p></li></ul><p>其中 $getmx(u,v)$ 表示从 $u$ 点到 $v$ 点的路径的花费。</p><p>前两个都很好理解，只有 $mx[u]=\max(mx[u],mx[v],getmx(mxi[u],mxi[v]))$ 可能要稍微想一下。因为他们的最大值要么是在 $u$ 的块中，要么是在 $v$ 的块中，要么就是经过新加的边的一条路经，而这条路径的花费就是 $getmx(mxi[u],mxi[v])$，所以取个max就好了。</p><p>问题就这样被解决了……</p><p>代码细节应该还好，虽然我交了几发才A，一定是wtcl。</p><h3 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code!"></a>Talk is cheap, show me the code!</h3><p><a href="https://codeforces.com/contest/1583/submission/132659594">Codeforces Status</a></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n,q;<br><span class="hljs-keyword">int</span> fun[<span class="hljs-number">200010</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> u,v,c,t;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Edge &amp;p)<span class="hljs-keyword">const</span>&#123;<br>        <span class="hljs-keyword">return</span> c&gt;p.c;<br>    &#125;<br>&#125;rec[<span class="hljs-number">200010</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Qry</span>&#123;</span><br>    <span class="hljs-keyword">int</span> v,x,ans,ansi,id;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Qry &amp;p)<span class="hljs-keyword">const</span>&#123;<br>        <span class="hljs-keyword">return</span> v&gt;p.v;<br>    &#125;<br>&#125;qry[<span class="hljs-number">200010</span>];<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">reorder</span><span class="hljs-params">(Qry x,Qry y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x.id&lt;y.id;<br>&#125;<br>vector&lt;Edge&gt; e[<span class="hljs-number">200010</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> t)</span></span>&#123;e[u].<span class="hljs-built_in">pb</span>((Edge)&#123;u,v,c,t&#125;);&#125;<br><span class="hljs-keyword">int</span> dep[<span class="hljs-number">200010</span>],fa[<span class="hljs-number">200010</span>][<span class="hljs-number">25</span>],mxval[<span class="hljs-number">200010</span>][<span class="hljs-number">25</span>];<br><span class="hljs-keyword">int</span> father[<span class="hljs-number">200010</span>],sz[<span class="hljs-number">200010</span>],mxi[<span class="hljs-number">200010</span>],mx[<span class="hljs-number">200010</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getmx</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(dep[u]&lt;dep[v]) <span class="hljs-built_in">swap</span>(u,v);<br>    <span class="hljs-keyword">int</span> dc=dep[u]-dep[v];<br>    <span class="hljs-built_in">Ror</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">20</span>) <span class="hljs-keyword">if</span>(dc&amp;(<span class="hljs-number">1</span>&lt;&lt;i))&#123;<br>        dc^=(<span class="hljs-number">1</span>&lt;&lt;i);<br>        <span class="hljs-built_in">ckmx</span>(ans,mxval[u][i]);<br>        u=fa[u][i];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-built_in">Ror</span>(i,<span class="hljs-number">0</span>,<span class="hljs-number">20</span>)&#123;<br>        <span class="hljs-keyword">if</span>(fa[u][i]!=fa[v][i])&#123;<br>            <span class="hljs-built_in">ckmx</span>(ans,<span class="hljs-built_in">max</span>(mxval[u][i],mxval[v][i]));<br>            u=fa[u][i];<br>            v=fa[v][i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">ckmx</span>(ans,<span class="hljs-built_in">max</span>(mxval[u][<span class="hljs-number">0</span>],mxval[v][<span class="hljs-number">0</span>]));<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> father[x]==x?x:father[x]=<span class="hljs-built_in">find</span>(father[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> fu=<span class="hljs-built_in">find</span>(u),fv=<span class="hljs-built_in">find</span>(v);<br>    <span class="hljs-keyword">if</span>(fu==fv) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(sz[fu]&lt;sz[fv]) <span class="hljs-built_in">swap</span>(fu,fv);  <br>    sz[fu]+=sz[fv];<br>    <span class="hljs-keyword">if</span>(fun[mxi[fu]]&gt;fun[mxi[fv]]);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fun[mxi[fu]]&lt;fun[mxi[fv]]) mxi[fu]=mxi[fv],mx[fu]=mx[fv];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fun[mxi[fu]]==fun[mxi[fv]]) mx[fu]=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(mx[fu],mx[fv]),<span class="hljs-built_in">getmx</span>(mxi[fu],mxi[fv]));<br>    father[fv]=fu;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> f,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    dep[u]=dep[f]+<span class="hljs-number">1</span>;<br>    fa[u][<span class="hljs-number">0</span>]=f;<br>    mxval[u][<span class="hljs-number">0</span>]=val;<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,<span class="hljs-number">20</span>)&#123;<br>        fa[u][i]=fa[fa[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>        mxval[u][i]=<span class="hljs-built_in">max</span>(mxval[u][i<span class="hljs-number">-1</span>],mxval[fa[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:e[u])&#123;<br>        <span class="hljs-keyword">int</span> v=p.v;<br>        <span class="hljs-keyword">if</span>(v==f) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(v,u,p.t);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    n=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) fun[i]=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<br>        rec[i].u=<span class="hljs-built_in">read</span>();<br>        rec[i].v=<span class="hljs-built_in">read</span>();<br>        rec[i].c=<span class="hljs-built_in">read</span>();<br>        rec[i].t=<span class="hljs-built_in">read</span>();<br>        <span class="hljs-built_in">add</span>(rec[i].u,rec[i].v,rec[i].c,rec[i].t);<br>        <span class="hljs-built_in">add</span>(rec[i].v,rec[i].u,rec[i].c,rec[i].t);<br>    &#125;<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,q)&#123;<br>        qry[i].v=<span class="hljs-built_in">read</span>();<br>        qry[i].x=<span class="hljs-built_in">read</span>();<br>        qry[i].id=i;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(rec+<span class="hljs-number">1</span>,rec+n);<br>    <span class="hljs-built_in">sort</span>(qry+<span class="hljs-number">1</span>,qry+q+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n)&#123;<br>        sz[i]=<span class="hljs-number">1</span>;<br>        father[i]=i;<br>        mxi[i]=i;<br>        mx[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,q)&#123;<br>        <span class="hljs-keyword">while</span>(pos+<span class="hljs-number">1</span>&lt;=n&amp;&amp;rec[pos].c&gt;=qry[i].v)&#123;<br>            <span class="hljs-built_in">merge</span>(rec[pos].u,rec[pos].v);<br>            pos++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> fx=<span class="hljs-built_in">find</span>(qry[i].x);<br>        qry[i].ansi=fun[mxi[fx]];<br>        qry[i].ans=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getmx</span>(qry[i].x,mxi[fx]),mx[fx]);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(qry+<span class="hljs-number">1</span>,qry+q+<span class="hljs-number">1</span>,reorder);<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,q)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld %lld\n&quot;</span>,qry[i].ansi,qry[i].ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 CF1583F 【Defender of Childhood Dreams】</title>
    <link href="/2021/10/21/%E9%A2%98%E8%A7%A3%20CF1583F%20%E3%80%90Defender%20of%20Childhood%20Dreams%E3%80%91/"/>
    <url>/2021/10/21/%E9%A2%98%E8%A7%A3%20CF1583F%20%E3%80%90Defender%20of%20Childhood%20Dreams%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p>一篇来自蒟蒻的题解，不喜误喷，有误请私信。</p><p><del>考场上都没来得及看题，wtcl。</del></p><h2 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h2><p>有 $n$ 个点，对于每两个点 $i,j$ 满足 $i&lt; j$，在 $i$ 与 $j$ 之间都会有一条连边。现在要对这 $\frac{n\times (n-1)}{2}$ 条边进行染色。要求对于每一条长度大于等于 $k$ 的路径，所有边的颜色种类至少要有两种。问至少要用几种颜色，并输出一种染色方案。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>是一道构造题，代码很好写，只要想清楚构造的方法。</p><p>首先，我们很容易发现（<del>甚至可以不发现</del>），只要保证每条长度为 $k$ 的路径满足条件，那么长度大于 $k$ 的所有路径都一定满足条件。证明随便想想，略。</p><p>我们先将 $1,2,3,\dots ,k$ 这些点之间的所有边都染上颜色 $1$ ，因为这 $k$ 个点之间的最长边的长度也没到 $k$ 。</p><p>同理，将 $k+1,k+2,k+3,\dots ,2k$ 之间的所有边都染上颜色 $1$ ，将 $2k+1,2k+2,2k+3,\dots ,3k$ 之间的所有边都染上颜色 $1$ ，以此类推，最后到 $k^2-k+1,k^2-k+2,k^2-k+3,\dots ,k^2$ 这些点之间的所有边都染上颜色 $1$，简单来说，就是现将 $n$ 以 $k$ 个元素为一组分组，组内全部边都染 $1$ 。</p><p>接下来，考虑将这 $n$ 个数按照 $k^2$ 个元素为一组再进行分组，属于同一组内的两个点间还没有染色的边都染上颜色 $2$，仔细想想，这要就能保证这 $k^2$ 个元素之间的所有长度等于 $k$ 的路径上的颜色种类数至少有两个了。如果想不明白，可以看下蒟蒻证明：</p><p>用反证法：假设有一条长度为 $k$ 的路径上的颜色种类只有 $1$ 种。</p><p>定义：一个 $k^2$ 个元素的分组叫做组，组内的每 $k$ 个元素组成的分组叫块。</p><ul><li><p>如果都是颜色 $1$，那么一定在同一个块内。已经证明了不可以。</p></li><li><p>如果都是颜色 $2$，那么采用贪心：从第一个块中任意一个点出发，走颜色为 $2$ 的边，一定回到第二个块中，再走走走，到第 $k$ 个块（即组内最后一个块），整条路径的长度也只有 $k-1$，不可能到 $k$。</p></li></ul><p>总上，假设不成立，故原名题得证。</p><p>证明了这点，接下来又是“以此类推”了。以 $k^3$ 个元素划分组，组内还未染色的边全部染成 $3$；再以 $k^4$ 个元素划分组，组内还未染色的边全部染成 $4$ ……</p><p>所以最后最少的颜色数量是 $\lceil \log_k n\rceil$。所有边的颜色上面都处理好了，直接输出即可。</p><h3 id="Talk-is-cheap-show-me-the-code"><a href="#Talk-is-cheap-show-me-the-code" class="headerlink" title="Talk is cheap, show me the code!"></a>Talk is cheap, show me the code!</h3><p><a href="https://codeforces.com/contest/1583/submission/132607093">Codeforces Status</a></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n=<span class="hljs-built_in">read</span>(),k=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>,sum=k;<br><span class="hljs-keyword">while</span>(sum&lt;n) ans++,sum*=k;<span class="hljs-comment">//计算⌈logkN⌉</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br><span class="hljs-built_in">For</span>(i,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>)&#123;<br>    <span class="hljs-built_in">For</span>(j,i+<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">int</span> x=i,y=j,d=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x!=y) x/=k,y/=k,d++;<span class="hljs-comment">//算每条边属于哪种跨度的</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,d);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 P7876 【「SWTR-07」Scores（hard version）】</title>
    <link href="/2021/10/06/%E9%A2%98%E8%A7%A3%20P7876%20%E3%80%90%E3%80%8CSWTR-07%E3%80%8DScores%EF%BC%88hard%20version%EF%BC%89%E3%80%91/"/>
    <url>/2021/10/06/%E9%A2%98%E8%A7%A3%20P7876%20%E3%80%90%E3%80%8CSWTR-07%E3%80%8DScores%EF%BC%88hard%20version%EF%BC%89%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h3 id="前言：立志写一篇清晰易懂的题解，虽然我一定是那个被吊打的人。"><a href="#前言：立志写一篇清晰易懂的题解，虽然我一定是那个被吊打的人。" class="headerlink" title="前言：立志写一篇清晰易懂的题解，虽然我一定是那个被吊打的人。"></a>前言：立志写一篇清晰易懂的题解，虽然我一定是那个被吊打的人。</h3><hr><p>题意就不说了。</p><p>先来判断无解的情况，有两种可能：</p><ul><li><p>A吊打了B，B吊打了C，C又吊打了A</p></li><li><p>A吊打了B，B吊打了C，C没有被A吊打</p></li></ul><p>判完无解情况后，我们可以将吊打关系转化为一张图。</p><p>假如 $a$ 吊打 $b$ ，那么我们就在 $a$ 与 $b$ 两个结点之间连一条有向边。</p><p>可以证明，最后建出来的图经过化简后，一定是由几条链组成的。</p><p>为什么？首先容易证明构成的图一定是一张DAG。然后要证明是几条链组成的，只要证明以下两种情况不可能：</p><p>1.有一个点同时连出多条边（此处以2为例，其余同理）</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zt545wmy.png"></p><p>根据题目：<strong>如果 $i,j$ 被同一个人吊打，或同时吊打同一个人，则他们之间也有一方被另一方吊打</strong>可知，图中 $p,q$ 两点之间一定有一条有向边。如：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/vqb6jdlp.png"></p><p>那么图中 $k,p$ 之间的连边可以删除，因此也可以看作一条链。</p><p>2.有多个条边同时连向一个点（此处以2为例，其余同理）</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fuyo0y14.png"></p><p>根据题目：<strong>如果 $i,j$ 被同一个人吊打，或同时吊打同一个人，则他们之间也有一方被另一方吊打</strong>可知，图中 $p,q$ 两点之间一定有一条有向边。如：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/wz6j8xvf.png"></p><p>那么图中 $q,i$ 之间的连边可以删除，因此也可以看作一条链。</p><p>知道了这点以后，就可以处理出每一条链中的元素与每一条链中元素的相对位置关系。</p><p>接下来，假设有 $3$ 条链，第一条链 $4$ 个元素，第二条链 $5$ 个元素，第三条链 $3$ 个元素，那么就可以通过两门学科构造出一种合法的情况如下：</p><p>每个元素一个二元组，每个二元组的第一个数表示第一门学科分数，第二个数表示第二门学科分数。</p><table><thead><tr><th>person1</th><th>person2</th><th>person3</th><th>person4</th><th>person5</th></tr></thead><tbody><tr><td>(100,1)</td><td>(99,2)</td><td>(98,3)</td><td>(97,4)</td><td></td></tr><tr><td>(96,5)</td><td>(95,6)</td><td>(94,7)</td><td>(93,8)</td><td>(92,9)</td></tr><tr><td>(91,10)</td><td>(90,11)</td><td>(89,12)</td><td></td><td></td></tr></tbody></table><p>这样就能满足题目要求了qwq。然后剩下的学科按照第一门学科的分数填充一下就好了。</p><p><strong>但是请注意</strong>： $m=1$ 时需要特判，即图中必须只能有一条合法的链，否则答案为<code>NO</code>。</p><p>最后代码实现就很简单了（代码和思路有些不一样，主要是因为再写题解释发现了一些其他的讲解方法，代码用作参考为主qwq）：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> justFUCK &#123;puts(<span class="hljs-meta-string">&quot;NO&quot;</span>);return;&#125;</span><br><span class="hljs-keyword">int</span> n,m,a[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<br><span class="hljs-keyword">int</span> fa[<span class="hljs-number">110</span>],king[<span class="hljs-number">110</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> fa[x]==x?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x)!=<span class="hljs-built_in">find</span>(y)) fa[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);&#125;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; son[<span class="hljs-number">110</span>];<br><span class="hljs-keyword">int</span> cnt[<span class="hljs-number">110</span>],ans[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<br><span class="hljs-keyword">bool</span> has[<span class="hljs-number">110</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    n=<span class="hljs-built_in">read</span>(),m=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">For</span>(j,<span class="hljs-number">1</span>,n) a[i][j]=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">For</span>(j,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">For</span>(k,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(i!=j&amp;&amp;j!=k&amp;&amp;k!=i&amp;&amp;a[i][j]==<span class="hljs-number">0</span>&amp;&amp;a[j][k]==<span class="hljs-number">0</span>&amp;&amp;a[i][k]==<span class="hljs-number">1</span>) justFUCK;<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i,cnt[i]=<span class="hljs-number">0</span>,king[i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">For</span>(j,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(i!=j&amp;&amp;a[i][j]==<span class="hljs-number">0</span>) <span class="hljs-built_in">merge</span>(i,j);<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) son[i].<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) son[<span class="hljs-built_in">find</span>(i)].<span class="hljs-built_in">pb</span>(i);<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(son[i].<span class="hljs-built_in">size</span>()!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//在这个组中只存在吊打关系(构成一条链)</span><br>        <span class="hljs-built_in">memset</span>(has,<span class="hljs-literal">false</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(has));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> u:son[i]) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:son[i]) <span class="hljs-keyword">if</span>(u!=v&amp;&amp;a[u][v]==<span class="hljs-number">0</span>) cnt[u]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> u:son[i])&#123;<br>            <span class="hljs-keyword">if</span>(has[cnt[u]]) justFUCK;<br>            has[cnt[u]]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(cnt[u]==<span class="hljs-number">0</span>) king[i]=u;<span class="hljs-comment">//这个人吊打了所有人，是这个组中最奆的人</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**m=1特判**/</span><br>    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">bool</span> check=<span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(king[i]!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(!check) check=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> justFUCK;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**m=1特判**/</span><br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">For</span>(j,<span class="hljs-number">1</span>,m) ans[i][j]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(son[i].<span class="hljs-built_in">size</span>()!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">int</span> sb=king[i];<br>        ans[sb][<span class="hljs-number">1</span>]=<span class="hljs-number">100</span>-tot;<br>        ans[sb][<span class="hljs-number">2</span>]=tot+son[i].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">For</span>(i,<span class="hljs-number">3</span>,m) ans[sb][i]=<span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j:son[i]) <span class="hljs-keyword">if</span>(j!=sb)&#123;<br>            <span class="hljs-built_in">For</span>(k,<span class="hljs-number">1</span>,m) ans[j][k]=ans[sb][k]-cnt[j];<br>        &#125;<br>        tot+=son[i].<span class="hljs-built_in">size</span>();<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>    <span class="hljs-built_in">For</span>(i,<span class="hljs-number">1</span>,n) &#123;<span class="hljs-built_in">For</span>(j,<span class="hljs-number">1</span>,m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i][j]); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>求管理员通过qwq</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 CF1572B 【Xor of 3】</title>
    <link href="/2021/10/04/%E9%A2%98%E8%A7%A3%20CF1572B%20%E3%80%90Xor%20of%203%E3%80%91/"/>
    <url>/2021/10/04/%E9%A2%98%E8%A7%A3%20CF1572B%20%E3%80%90Xor%20of%203%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h3 id="前言：立志写一篇清晰、简洁的题解。"><a href="#前言：立志写一篇清晰、简洁的题解。" class="headerlink" title="前言：立志写一篇清晰、简洁的题解。"></a>前言：立志写一篇清晰、简洁的题解。</h3><hr><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给你一个由 $0$ 和 $1$ 组成的序列 $a$ ，要求你对这个序列进行不超过序列长度 $n$ 次的如下操作：</p><p>选定一个 $i$ ，满足 $1\le i \le n-2$ ，将 $a_i,a_{i+1},a_{i+2}$ 三个元素的值都更改为 $a_i\bigoplus a_{i+1}\bigoplus a_{i+2}$ 的值。问你如何操作使得 $a$ 中所有元素的值都变成 $0$ 。如果可行，输出任意方案，否则输出 <code>NO</code> ，表示无解。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>蒟蒻根本不会巨佬们的方法，于是进行了普通的分类讨论。</p><p>第一部肯定要将 $a_1$ 变成 $0$ 。</p><ul><li><p>   如果 $a_1=0$ ，直接跳开着一步。</p></li><li><p>   如果 $a_1=1$ ，那么分情况：</p></li></ul><div class="hljs code-wrapper"><pre><code>-    如果前三个数分别是 $1,1,0$ 或者 $1,0,1$ ，那么直接将前面三个数字进行操作即可。-    如果前三个数分别是 $1,1,1$ 或者 $1,0,0$ ，那么发现没办法直接将第一个元素变为 $0$ ，那么就要先改变后面的（第二、三个）元素。如果二、三个元素同时改变，那么改变后他们的值也一定相同，异或后也一定是 $0$ ，并无法改变第一个元素的值。因此只能在第三个元素上做文章。    如果第三个元素的后面两个元素（即第四、五个元素）异或的结果为 $1$ ，那么他们就能改变第三个元素的值，进而能将第一个元素改变为 $0$ 。如果不能，那么就继续往后找，找到为之，再往前一组组进行操作。如果找到最后也找不到，那么一定是 `NO` 了。</code></pre></div><p>现在第一个元素已经变为 $0$ 了。</p><p>好，接下来我们假设数组前面已经有了一堆连续的 $0$ （至少一个），接下来分4种情况讨论（以下情况均令第一个 $1$ 的位置为 $i$ ，且满足 $1\le i \le n-2$ ）：</p><ul><li>   序列为： $0,0\dots 0,1,0,0$ 。</li></ul><div class="hljs code-wrapper"><pre><code>操作方法：将 $i,i+1,i+2$ 三个位置进行一次操作，变成 $0,0\dots 0,1,1,1$ ，再将 $i-1,i,i+1$ 三个位置进行一次操作，变成 $0,0\dots 0,0,0,1$ 。2次操作在序列后面多了2个 $0$ 。</code></pre></div><ul><li>   序列为： $0,0\dots 0,1,0,1$ 。</li></ul><div class="hljs code-wrapper"><pre><code>操作方法：将 $i,i+1,i+2$ 三个位置进行一次操作，变成 $0,0\dots 0,0,0,0$ 。1次操作在序列后面多了1个 $0$ 。</code></pre></div><ul><li>   序列为： $0,0\dots 0,1,1,0$ 。</li></ul><div class="hljs code-wrapper"><pre><code>操作方法：将 $i,i+1,i+2$ 三个位置进行一次操作，变成 $0,0\dots 0,0,0,0$ 。1次操作在序列后面多了1个 $0$ 。</code></pre></div><ul><li>   序列为： $0,0\dots 0,1,1,1$ 。</li></ul><div class="hljs code-wrapper"><pre><code>操作方法：将 $i-1,i,i+1$ 三个位置进行一次操作，变成 $0,0\dots 0,0,0,1$ 。1次操作在序列后面多了2个 $0$ 。</code></pre></div><p>最后，经过操作，能保证序列的前 $n-2$ 个元素都是 $0$ 。</p><p>至于最后两个元素：</p><ul><li><p>   为 $0,0$ ，不用动。</p></li><li><p>   为 $1,0$ ，无解，输出 <code>NO</code> 。</p></li><li><p>   为 $0,1$ ，无解，输出 <code>NO</code> 。</p></li><li><p>   为 $1,1$ ，将 $n-2,n-1,n$ 三个元素进行一次操作即可。</p></li></ul><p>最后，统计操作次数时发现，每次操作均摊下来，要么能是序列后面多1个 $0$ ，要么能是序列后面多1.5个 $0$ 。至于前面的将第一个元素变为 $0$ 的操作来看，假如他最后搜到了第 $pos$ 个元素才能找到能行的操作，那么退回来的操作次数不会超过 $\frac{pos}{2}$ 次，然而继续往后增加 $0$ 的那个操作，操作到 $pos$ 位置的操作次数也不会超过 $\frac{pos}{2}$ 次。因此，最终的操作次数一定是小于等于 $n$ 次的。因此就不用担心操作次数的问题了qwq。</p><p>一些细节还是看代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n,a[<span class="hljs-number">200010</span>];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<span class="hljs-comment">//存储操作方法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    ans.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//多测清空</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<span class="hljs-comment">//不想写快读</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(i+<span class="hljs-number">2</span>&gt;n)&#123;<span class="hljs-comment">//找不到能行的位置，直接NO</span><br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(a[i+<span class="hljs-number">1</span>]^a[i+<span class="hljs-number">2</span>]==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//找到的能行的位置</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            i+=<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//回撤操作</span><br>            a[i]^=a[i+<span class="hljs-number">1</span>]^a[i+<span class="hljs-number">2</span>];<br>            a[i+<span class="hljs-number">1</span>]=a[i+<span class="hljs-number">2</span>]=a[i];<br>            ans.<span class="hljs-built_in">push_back</span>(i);<br>            i-=<span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n<span class="hljs-number">-2</span>;i++)&#123;<span class="hljs-comment">//逐渐往后加0</span><br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>&amp;&amp;a[i+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>&amp;&amp;a[i+<span class="hljs-number">2</span>]==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//四种情况</span><br>            ans.<span class="hljs-built_in">push_back</span>(i);<br>            a[i]=a[i+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>&amp;&amp;a[i+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>&amp;&amp;a[i+<span class="hljs-number">2</span>]==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//四种情况</span><br>            ans.<span class="hljs-built_in">push_back</span>(i);<br>            a[i]=a[i+<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>&amp;&amp;a[i+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>&amp;&amp;a[i+<span class="hljs-number">2</span>]==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//四种情况</span><br>            ans.<span class="hljs-built_in">push_back</span>(i<span class="hljs-number">-1</span>);<br>            a[i]=a[i+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>&amp;&amp;a[i+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>&amp;&amp;a[i+<span class="hljs-number">2</span>]==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//四种情况</span><br>            ans.<span class="hljs-built_in">push_back</span>(i);<br>            ans.<span class="hljs-built_in">push_back</span>(i<span class="hljs-number">-1</span>);<br>            a[i]=<span class="hljs-number">0</span>;<br>            a[i+<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(a[n<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>&amp;&amp;a[n]==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//判断最后两个元素的情况</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[n<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>&amp;&amp;a[n]==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[n<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>&amp;&amp;a[n]==<span class="hljs-number">1</span>)&#123;<br>        ans.<span class="hljs-built_in">push_back</span>(n<span class="hljs-number">-2</span>);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,(<span class="hljs-keyword">int</span>)ans.<span class="hljs-built_in">size</span>());<span class="hljs-comment">//输出答案</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:ans)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,p);<br>    &#125;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>完结散花！</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 CF1566D2 【Seating Arrangements (hard version)】</title>
    <link href="/2021/10/04/%E9%A2%98%E8%A7%A3%20CF1566D2%20%E3%80%90Seating%20Arrangements%20(hard%20version)%E3%80%91/"/>
    <url>/2021/10/04/%E9%A2%98%E8%A7%A3%20CF1566D2%20%E3%80%90Seating%20Arrangements%20(hard%20version)%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p>楼上巨佬们基本全都是用数状数组写的，蒟蒻太懒，不想写，于是写了一种简单做法。</p><p>题意不再赘述，巨佬门都讲解得很清楚了。</p><p>首先，这道题中能换位置的元素只有视力相同的观众。所以，现按照视力从小到大排个序，确定每组视力相同的人的相对位置关系。</p><p>然后就可以对相同视力的群体内部进行排序。</p><p>分行排序，每行以视力为第一关键字，<code>id</code>为第二关键字（从大到小）再进行排序，这样就能保证方便值最小。</p><p>最后每行再 $m^2$ 统计一下，时间复杂度 $O(n\times m^2)$ 。</p><p><del>算法很暴力，但数据很水</del></p><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> val,id;<br>&#125;a[<span class="hljs-number">90010</span>];<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x,node y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x.val!=y.val)&#123;<br>        <span class="hljs-keyword">return</span> x.val&lt;y.val;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> x.id&lt;y.id;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp2</span><span class="hljs-params">(node x,node y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x.val!=y.val)&#123;<br>        <span class="hljs-keyword">return</span> x.val&lt;y.val;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> x.id&gt;y.id;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*m;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i].val);<br>        a[i].id=i;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n*m+<span class="hljs-number">1</span>,cmp);<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">sort</span>(a+m*(i<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>,a+m*i+<span class="hljs-number">1</span>,cmp2);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;j;k++)&#123;<br>                <span class="hljs-keyword">if</span>(a[m*(i<span class="hljs-number">-1</span>)+k].id&lt;a[m*(i<span class="hljs-number">-1</span>)+j].id)&#123;<br>                    ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        <span class="hljs-built_in">work</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性筛&amp;线性求欧拉函数&amp;inv</title>
    <link href="/2021/07/18/%E7%BA%BF%E6%80%A7%E7%AD%9B&amp;%E7%BA%BF%E6%80%A7%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0&amp;inv/"/>
    <url>/2021/07/18/%E7%BA%BF%E6%80%A7%E7%AD%9B&amp;%E7%BA%BF%E6%80%A7%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0&amp;inv/</url>
    
    <content type="html"><![CDATA[<p>这似乎不是给别人看的。</p><p>只是想自己忘记的时候看一下。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//线性筛</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1000000</span>;i++)&#123;<br><span class="hljs-keyword">if</span>(!flag[i])&#123;<br>prim[++tot]=i;<br>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=tot;j++)&#123;<br><span class="hljs-keyword">if</span>(i*prim[j]&gt;<span class="hljs-number">1000000</span>)&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>            flag[i*prim[j]]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(i%prim[j]==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//线性求欧拉函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!flag[i])&#123;<br>            p[++tot]=i;<br>            phi[i]=i<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;tot;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i*p[j]&gt;n)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            flag[i*p[i]]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>)&#123;<br>                phi[i*p[j]]=phi[i]*p[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            phi[i*p[j]]=phi[i]*(p[j]<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//inv(exgcd)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x,y;<br>    <span class="hljs-built_in">exgcd</span>(b,c,x,y);<br>    x=(x%c+c)%c;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-comment">//inv(线性预处理)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> P)</span></span>&#123;<br>    inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        inv[i]=(P-P/i)*inv[P%i]%P;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扩展欧几里得</title>
    <link href="/2021/06/01/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    <url>/2021/06/01/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="扩展欧几里得-exgcd"><a href="#扩展欧几里得-exgcd" class="headerlink" title="扩展欧几里得(exgcd)"></a>扩展欧几里得(exgcd)</h1><p>扩展欧几里得的典型应用是解决形如</p><p>$$<br>a\times x+b\times y=c<br>$$</p><p>的二元一次方程的解的存在性问题以及求出特解与通解。</p><h2 id="解的存在性问题"><a href="#解的存在性问题" class="headerlink" title="解的存在性问题"></a>解的存在性问题</h2><p>其实我们可以通过辗转相减法观察出来，$a,b$辗转相减的时候相当于$a\times x+b\times y$中的$x,y$不断变化的过程。我们通过前面的知识知道，这一个过程后，一定能得出最大公约数，所以$a\times x+b\times y=gcd(a,b)$一定有解，那么是否$gcd(x,y)≠c$时就无解呢？</p><p>首先我们知道$c$是$gcd(a,b)$的倍数才可能有解，因为左边一定含有质因子$gcd(a,b)$，左边等于右边，则右边也一定含有$gcd(a,b)$，因此我们可以通过两边同时除以$gcd(a,b)$得到一个新的式子：</p><p>$$<br>k_1\times x+k_2\times y=c/g,gcd(k1,k2)=1<br>$$</p><p>由辗转相减可得：$k_1\times x+k_2\times y=1$一定有解。所以，$k_1\times x+k_2\times y=c/g$一定有解。</p><p>所以，当$c$是$gcd(a,b)$的倍数时，方程一定有解。</p><h2 id="特解与通解"><a href="#特解与通解" class="headerlink" title="特解与通解"></a>特解与通解</h2><p>所以我们只要求形如：</p><p>$$<br>a\times x+b\times y=gcd(a,b)<br>$$</p><p>然后，将解扩大$c/gcd(a,b)$倍就可以得出方程的解了。</p><p>观察式子本质就是$a$和$b$辗转相减的过程。假设已经求出了</p><p>$$<br>(a-b)\times x_1+b\times y_1=gcd(a,b)<br>$$</p><p>的解$x_1,y_1$，那么变换一下就可以得到</p><p>$$<br>a\times x_1+b\times (y_1-x_1)=gcd(a,b)<br>$$</p><p>我们可以得出</p><p>$$<br>x=x_1,y=y_1-x_1<br>$$</p><p>得到了原方程的解，所以我们可以将原问题转化为一个规模更小的子问题。然后根据子问题的答案推出原问题的答案。考虑到这个辗转相减可以用辗转相除来替代，我们可以将求解原问题转化为求解</p><p>$$<br>b\times x_1+a% b\times y_1=gcd(a,b)<br>$$</p><p>由：</p><p>$$<br>a% b=a-a/b\times b<br>$$</p><p>代入得：</p><p>$$<br>b\times x_1+(a-a/b\times b)\times y_1=gcd(a,b)<br>$$</p><p>等价于：</p><p>$$<br>a\times y_1+b\times (x_1-a/b*y_1)=gcd(a,b)<br>$$</p><p>得到：</p><p>$$<br>x=y_1,y=x_1-a/b*y_1<br>$$</p><p>因此，我们只需要一直缩小问题的规模，直到变成$gcd(a,b)\times x+0\times y=gcd(a,b)$，然后得到一组解$(1,0)$，在这组解反推回去，得到一组原方程的特解。该过程可以用一个函数来实现。</p><p><strong>代码：</strong></p><p>$$<br>exgcd<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span>&#123;<br><span class="hljs-keyword">int</span> d=a;<br><span class="hljs-keyword">if</span>(b!=<span class="hljs-number">0</span>)&#123;<br>d=<span class="hljs-built_in">exgcd</span>(b,a%b,x,y);<br>x-=(a/b)*y;<br><span class="hljs-built_in">swap</span>(x,y);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>函数执行完毕后，代码里的$(x,y)$就是$a\times x+b\times y=gcd(a,b)$的一组特解。通解的变化规律就是$x,y$的值往相反的方向变化，比如$x$变大一点，$y$变小一点，使得答案不变，设这个变化的最小单位为$d_1,d_2$。</p><p>$$<br>a\times (x+d_1)+b\times (y-d_2)=gcd(a,b)<br>$$</p><p>$$<br>a\times d_1=b\times d_2<br>$$</p><p>两边同除$gcd(a,b)$令$k_1=a/gcd(a,b),k_2=b/gcd(a,b)$</p><p>$$<br>k_1\times d_1=k_2\times d_2<br>$$</p><p>此时，$gcd(k_1,k_2)=1$，显然$d_1=k_2,d_2=k_1$，可得通解为：</p><p>$$<br>(x+k\times d_1,y-k\times a/gcd(a,b))<br>$$</p><h2 id="特解的绝对值大小"><a href="#特解的绝对值大小" class="headerlink" title="特解的绝对值大小"></a>特解的绝对值大小</h2><p>我们通过递归函数的实现可以观察到，解的绝对值是跟$a,b$的绝对值同一个级别的。（即传入与传出的数据不会相差太大，如传入的很小，传出的<strong>爆炸</strong>）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 P1275 【魔板】</title>
    <link href="/2021/02/11/%E9%A2%98%E8%A7%A3%20P1275%20%E3%80%90%E9%AD%94%E6%9D%BF%E3%80%91/"/>
    <url>/2021/02/11/%E9%A2%98%E8%A7%A3%20P1275%20%E3%80%90%E9%AD%94%E6%9D%BF%E3%80%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1275">这道题</a>的思路总体比较明确。 </p><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><hr><p>首先，介绍一个 <code>change</code> 函数。</p><p>这道题目中的操作2表述为：</p><ul><li>任选两列，交换其位置。</li></ul><p>所以，我们可以先写一个函数用于完成这一个操作。</p><p>假设要交换 $x$ ， $y$ 两列，那么只需要一个简单的循环即可实现，上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">swap</span>(a[i][x],a[i][y]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当然，在我自己的代码中，直接把这几段内嵌主函数了，但其实用了两次，写个函数会更简洁。</p><hr><p>接着，就是一个 <code>check</code> 函数，用于比较交换后的 $x$ 列与目标的 $y$ 列的元素是否匹配。不加赘述，直接上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(a[i][x]!=b[i][y])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><hr><p>至于第一项操作：</p><ul><li>任选一行，改变该行中所有灯泡的状态，即亮的变暗、暗的变亮。</li></ul><p>我们分析可以知道，对于每一行来说，最多只会进行一次这种操作。如果超过一次，进行了 $n$ 次这一种操作，就相当于进行了 $n%2$ 次操作，是没有意义的。</p><p>因此，我们就没有必要再写一个函数来完成这个任务了，代码很短，直接内嵌即可。</p><hr><p>总体来说，我们首先需要第一列与每一列交换的情况。</p><p>然后将变换后的魔板与目标的魔板进行对比，只要对比第一列的元素，如果不同，那么就将这一行全部进行第一项操作。</p><p>最后，对变换后的魔板，枚举第 $2$<del>$m$ 列与目标矩阵的 $2$</del>$m$ 列进行比较。如果是一样的话，就说明这一种交换方式是可行的。</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>总体来讲，这一道题的思路比较<del>简单</del>，容易理解。具体的实现看代码：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fsyjmao5.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 P7072 【直播获奖（民间数据）】</title>
    <link href="/2020/11/11/%E9%A2%98%E8%A7%A3%20P7072%20%E3%80%90%E7%9B%B4%E6%92%AD%E8%8E%B7%E5%A5%96%EF%BC%88%E6%B0%91%E9%97%B4%E6%95%B0%E6%8D%AE%EF%BC%89%E3%80%91/"/>
    <url>/2020/11/11/%E9%A2%98%E8%A7%A3%20P7072%20%E3%80%90%E7%9B%B4%E6%92%AD%E8%8E%B7%E5%A5%96%EF%BC%88%E6%B0%91%E9%97%B4%E6%95%B0%E6%8D%AE%EF%BC%89%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一看到这道题，首先想到的就是直接暴力模拟。我们可以开一个数组来从小到大储存分数，每次询问只需要输出 $a[want]$ 就可以了。</p><p>为了减小时间复杂度，我们尽可能不用 $sort$ 排序，因为每一次插入直插入 $1$ 个元素，所以我们可以找到每次想要插入的位置，把后面的直接全部往后推一位，再插入即可。</p><p>但是，如果每次都是在第一位插入，那么不难发现，复杂度是 $O_{n^2}$ 的，看一下数据范围， $n\le 10^5$ ，最大需要 $10^{10}$ 的复杂度，显然会 $TLE$ 。所以不能这样做。</p><p>我们再来看一下题目：虽然 $n$ 很大，但是分数最大也就只有 $600$ 分。所以，我们不难想到用<strong>桶排</strong>。</p><p>开一个大小为 $600$ 的桶，命名为 $cnt$ 。其中， $cnt_i$ 表示分数 $i$ 出现的次数，那么插入的复杂度是 $O_1$ 的。每次查询只需要从大到小直接查询即可。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入的代码很简单，输入一个分数 $i$ ，只要将 $cnt_i+1$ 即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;i);<br>cnt[i]++;<br></code></pre></div></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>首先计算出可以入选的总人数，然后从大到小加上该分数段的人数，只要人数 $\geq$ 需要人数，那么直接输出现在的分数即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> most_people=<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,p*w/<span class="hljs-number">100</span>);<br><span class="hljs-keyword">int</span> cho_people=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">600</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>cho_people+=cnt[i];<br><span class="hljs-keyword">if</span>(cho_people&gt;=most_people)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure><p>其中， $ans$ 是一个 <code>vector</code> ， $most_people$ 是需要的人数， $p$ 是现在一共有几个人。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>讲了那么多，终于可以上 $code$ 了！</p><p>$code$:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,w;<br><span class="hljs-keyword">int</span> cnt[<span class="hljs-number">610</span>];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">int</span> most_people=<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,p*w/<span class="hljs-number">100</span>);<br><span class="hljs-keyword">int</span> cho_people=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">600</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>cho_people+=cnt[i];<br><span class="hljs-keyword">if</span>(cho_people&gt;=most_people)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//freopen(&quot;live.in&quot;,&quot;r&quot;,stdin);</span><br><span class="hljs-comment">//freopen(&quot;live.out&quot;,&quot;w&quot;,stdout);</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;w);<br><span class="hljs-keyword">int</span> s;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;s);<br>cnt[s]++;<br><span class="hljs-built_in">check</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ans.<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans[i]);<br>&#125;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//fclose(stdin);</span><br><span class="hljs-comment">//fclose(stdout);</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题毕竟只有<code>普及-</code>的难度，所以只要用到一个<strong>桶排</strong>的思想就可以了。总体来说思维难度与代码实现难度都不大。<del>是一道水题。</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 CF1445B 【Elimination】</title>
    <link href="/2020/11/06/%E9%A2%98%E8%A7%A3%20CF1445B%20%E3%80%90Elimination%E3%80%91/"/>
    <url>/2020/11/06/%E9%A2%98%E8%A7%A3%20CF1445B%20%E3%80%90Elimination%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有两场比赛：</p><p>第一场的第 $100$ 名成绩为$a$，且第一场的人在第二场得分至少为$b$。</p><p>第二场的第 $100$ 名成绩为$c$，且第二场的人在第一场的得分至少$d$。</p><p>求两场比赛成绩加和后第$100$名的最少成绩是多少</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题是一道很明显的数学题。我们来观察一下样例：</p><p><code>1 2 2 1</code></p><p>答案是 <code>3</code></p><p><code>4 8 9 2</code></p><p>答案是 <code>12</code></p><p>不难发现，答案就是$a+b$与$c+d$的较小值。也就是说，是第一场前$100$名的总分与第二场$100$名的总分。</p><p>所以，答案直接输出$max(a+b,c+d)$就可以了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> t;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br><span class="hljs-keyword">int</span> a,b,c,d;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">max</span>(a+b,c+d));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 CF1445A 【Array Rearrangment】</title>
    <link href="/2020/11/05/%E9%A2%98%E8%A7%A3%20CF1445A%20%E3%80%90Array%20Rearrangment%E3%80%91/"/>
    <url>/2020/11/05/%E9%A2%98%E8%A7%A3%20CF1445A%20%E3%80%90Array%20Rearrangment%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h3 id="小菜一碗（正在建设）"><a href="#小菜一碗（正在建设）" class="headerlink" title="小菜一碗（正在建设）"></a><a href="https://wsyear.github.io/">小菜一碗（正在建设）</a></h3><h3 id="配合食用更佳"><a href="#配合食用更佳" class="headerlink" title="配合食用更佳"></a><a href="https://www.luogu.com.cn/blog/wsy1113hzbook/">配合食用更佳</a></h3><h1 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h1><p>题目描述确实有些累赘，这里来个简化版的题目：</p><p>有$t$组数据，每组数据给出两个长度为$n$的数组$a$，$b$与一个整数$x$，我们需要将$b$数组重新排序，然后可以理解为把他们一一对齐，而后每一个竖列的和都不能大于$x$。问你是否能够做到。</p><p>我们以第一组数据为例，来分析题目：</p><table><thead><tr><th align="center">数组标号</th><th align="center">元素1</th><th align="center">元素2</th><th align="center">元素3</th></tr></thead><tbody><tr><td align="center">$A$</td><td align="center">$1$</td><td align="center">$2$</td><td align="center">$3$</td></tr><tr><td align="center">$B$</td><td align="center">$1$</td><td align="center">$1$</td><td align="center">$2$</td></tr></tbody></table><p>我们可以吧$A$数组给从小到大排序，$B$数组给从大到小排序。得到：</p><table><thead><tr><th align="center">数组标号</th><th align="center">元素1</th><th align="center">元素2</th><th align="center">元素3</th></tr></thead><tbody><tr><td align="center">$A$</td><td align="center">$1$</td><td align="center">$2$</td><td align="center">$3$</td></tr><tr><td align="center">$B$</td><td align="center">$2$</td><td align="center">$1$</td><td align="center">$1$</td></tr></tbody></table><p>我们可以发现，如果要让他们的和都小于$x$，那么尽量让他们的值平均。所以我们只要将$A$数组从前往后遍历，$B$数组从后往前遍历，只要有有一组的和大于了$x$，那么就不可以，如果全部遍历完了还没挂，那么一定可以。</p><p>直接上$code$:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">55</span>],b[<span class="hljs-number">55</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        <span class="hljs-keyword">int</span> n,x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b[i]);<br>        <span class="hljs-keyword">bool</span> ans=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,j=n;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i]+b[j]&gt;x)&#123;<br>                ans=<span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            j--;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(ans==<span class="hljs-literal">true</span>?<span class="hljs-string">&quot;Yes\n&quot;</span>:<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="终"><a href="#终" class="headerlink" title="终"></a>终</h3>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 P3956 【棋盘】</title>
    <link href="/2020/11/05/%E9%A2%98%E8%A7%A3%20P3956%20%E3%80%90%E6%A3%8B%E7%9B%98%E3%80%91/"/>
    <url>/2020/11/05/%E9%A2%98%E8%A7%A3%20P3956%20%E3%80%90%E6%A3%8B%E7%9B%98%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Problem-传输门"><a href="#Problem-传输门" class="headerlink" title="Problem_传输门"></a><a href="https://www.luogu.com.cn/problem/P3956">Problem_传输门</a></h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>看一看各位大佬们的题解，大部分都是用<strong>DFS</strong>或者<strong>特殊BFS</strong>的，但是仔细看一看这道题目的数据范围：$m \le 100 ,n \le 1000$。</p><p>所以，这道题如果数据比较强悍，各位大佬的方法是过不了的<del>（sorry）</del>。</p><p>这道题的正解应该用Dijkstra。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>——这道题是最短路？</p><p>——怎么可能？</p><p>尽管这道题看起来一点也不像最短路径，但是，事实告诉我们，这道题可以用拆点的方法来<strong>转化</strong>为最短路径。</p><p>首先，我们来考虑最基础、最重要也是最难的<strong>建图</strong>部分。</p><p>我们不能直接把这张图转化，如果考虑最差情况，我们所建出的图的的大小为$2\times m^2$个节点。</p><p>我们把一个无色的点分成两个点，一个点是红色，一个点是黄色。而一个有色的点，我们就用这一个节点。</p><p>那么，每个点的坐标该怎么储存呢？</p><p>我们可以把一个点的标号用一个get函数求出来：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> f)</span></span><br><span class="hljs-function"></span>&#123;<br>    f--;<br>    <span class="hljs-keyword">return</span> f*m*m+x*m+y;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中，<code>f=1</code>时，表示在原图上储存；<code>f=2</code>是，表示在衍生图上。</p><p>知道了应该建哪些节点，那么，每条边的权值应该如何定义呢？</p><p>I.有色到有色</p><p>1.同色转移：边权为0</p><p>2.异色转移：边权为1</p><p>II.无色到有色</p><p>1.这个变成红色</p><p>若后面为红色，边权为0</p><p>若后面为黄色，边权为1</p><p>2.这个变成黄色</p><p>若后面为黄色，边权为0</p><p>若后面为红色，边权为1</p><p>III.有色到无色</p><p>1.若这个是黄色</p><p>变成黄色，边权为2</p><p>变成红色，边权为3</p><p>2.若这个是红色</p><p>变成黄色，边权为3</p><p>变成红色，边权为2</p><p>IV.无色到无色</p><p>无法转移</p><p>所以我们可以这样写代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><br><span class="hljs-keyword">if</span>(c[i][j]&amp;&amp;c[x][y])<br>&#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,c[i][j]),<span class="hljs-built_in">id</span>(x,y,c[x][y]),(c[i][j]!=c[x][y]));<br>&#125;<br><span class="hljs-keyword">if</span>(c[i][j]&amp;&amp;!c[x][y])<br>&#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,c[i][j]),<span class="hljs-built_in">id</span>(x,y,<span class="hljs-number">1</span>),<span class="hljs-number">2</span>+(c[i][j]!=<span class="hljs-number">1</span>));<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,c[i][j]),<span class="hljs-built_in">id</span>(x,y,<span class="hljs-number">2</span>),<span class="hljs-number">2</span>+(c[i][j]!=<span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-keyword">if</span>(!c[i][j]&amp;&amp;c[x][y])<br>&#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">1</span>),<span class="hljs-built_in">id</span>(x,y,c[x][y]),(c[x][y]!=<span class="hljs-number">1</span>));<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">2</span>),<span class="hljs-built_in">id</span>(x,y,c[x][y]),(c[x][y]!=<span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-keyword">if</span>(!c[i][j]&amp;&amp;!c[x][y])<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样就可以完成建边了！</p><p>接下来的问题就变得简单了：图已经建完了，只需要跑一边Dijkstra+heap就能得出答案了！<del>QAQ</del></p><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>如果你不会<code>Dijkstra</code>算法，你可以点进这道题：<a href="https://www.luogu.com.cn/problem/P4779">【模板】单源最短路径（标准版）</a>，来练习<code>Dijkstra+heap</code>，这里就不给大家具体介绍这个算法的原理了，直接附上一个<code>Dijkstra+heap</code>的标程吧！</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>d[i]=INF;<br>d[s]=<span class="hljs-number">0</span>;<br>priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">-0</span>,s));<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; f=q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">int</span> u=f.second;<br><span class="hljs-keyword">int</span> dist=-f.first;<br><span class="hljs-keyword">if</span>(d[u]&lt;dist)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];i!=<span class="hljs-number">-1</span>;i=nxt[i])<br>&#123;<br><span class="hljs-keyword">if</span>(d[u]+w[i]&lt;d[to[i]])<br>&#123;<br>d[to[i]]=d[u]+w[i];<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(-d[to[i]],to[i]));<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>思路都搞定了，只剩一个建图了。建图得用邻接表。我一般不喜欢用<code>vector</code>，用的是<code>链式前向星</code>。</p><p>讲了那么多，终于上代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> c[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">20010</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M=<span class="hljs-number">40010</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> head[N];<br><span class="hljs-keyword">int</span> w[M],to[M],from[M],nxt[M];<br><span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> f)</span></span><br><span class="hljs-function"></span>&#123;<br>    f--;<br>    <span class="hljs-keyword">return</span> f*m*m+x*m+y;<br>&#125;<br><span class="hljs-keyword">int</span> dx[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> dy[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    tot++;<br>    w[tot]=c;<br>    to[tot]=b;<br>    from[tot]=a;<br>    nxt[tot]=head[a];<br>    head[a]=tot;<br>&#125;<br><span class="hljs-keyword">int</span> d[N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=N;i++)<br>        d[i]=INF;<br>    priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; q;<br>    d[<span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])]=<span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">-0</span>,<span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])));<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; f;<br>        f=q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">int</span> dist=-f.first;<br>        <span class="hljs-keyword">int</span> u=f.second;<br>        <span class="hljs-keyword">if</span>(d[u]&lt;dist)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// cout&lt;&lt;&quot;F*ck!&quot;&lt;&lt;endl;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];i!=<span class="hljs-number">-1</span>;i=nxt[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(d[u]+w[i]&lt;d[to[i]])<br>            &#123;<br>                d[to[i]]=d[u]+w[i];<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(-d[to[i]],to[i]));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<br>    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-number">-1</span>));<br>    <span class="hljs-keyword">int</span> x,y,f;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;f);<br>        c[x<span class="hljs-number">-1</span>][y<span class="hljs-number">-1</span>]=f+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=N;i++)<br>        head[i]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)<br>            &#123;<br>                <span class="hljs-keyword">int</span> x=i+dx[k];<br>                <span class="hljs-keyword">int</span> y=j+dy[k];<br>                <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=m||y&lt;<span class="hljs-number">0</span>||y&gt;=m)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(c[i][j]&amp;&amp;c[x][y])<br>                &#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,c[i][j]),<span class="hljs-built_in">id</span>(x,y,c[x][y]),(c[i][j]!=c[x][y]));<br>&#125;<br><span class="hljs-keyword">if</span>(c[i][j]&amp;&amp;!c[x][y])<br>                &#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,c[i][j]),<span class="hljs-built_in">id</span>(x,y,<span class="hljs-number">1</span>),<span class="hljs-number">2</span>+(c[i][j]!=<span class="hljs-number">1</span>));<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,c[i][j]),<span class="hljs-built_in">id</span>(x,y,<span class="hljs-number">2</span>),<span class="hljs-number">2</span>+(c[i][j]!=<span class="hljs-number">2</span>));<br>&#125;<br><span class="hljs-keyword">if</span>(!c[i][j]&amp;&amp;c[x][y])<br>                &#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">1</span>),<span class="hljs-built_in">id</span>(x,y,c[x][y]),(c[x][y]!=<span class="hljs-number">1</span>));<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">id</span>(i,j,<span class="hljs-number">2</span>),<span class="hljs-built_in">id</span>(x,y,c[x][y]),(c[x][y]!=<span class="hljs-number">2</span>));<br>&#125;<br>            &#125;<br>    <span class="hljs-built_in">dijkstra</span>();<br>    cout&lt;&lt;(<span class="hljs-built_in">min</span>(d[<span class="hljs-built_in">id</span>(m<span class="hljs-number">-1</span>,m<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)],d[<span class="hljs-built_in">id</span>(m<span class="hljs-number">-1</span>,m<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>)])==INF?<span class="hljs-number">-1</span>:<span class="hljs-built_in">min</span>(d[<span class="hljs-built_in">id</span>(m<span class="hljs-number">-1</span>,m<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)],d[<span class="hljs-built_in">id</span>(m<span class="hljs-number">-1</span>,m<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>)]));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题竟然能用<code>dfs</code>水过！<del>测试点太水了！</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间复杂度的推演</title>
    <link href="/2020/10/10/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%8E%A8%E6%BC%94/"/>
    <url>/2020/10/10/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%8E%A8%E6%BC%94/</url>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度的推演"><a href="#时间复杂度的推演" class="headerlink" title="时间复杂度的推演"></a>时间复杂度的推演</h1><p>在信奥的初赛中，往往会出现关于 $时间复杂度$ 的递推式分析，其一般形式为：</p><p><strong>T(n)=aT(n/b)+c(n^d)</strong></p><p>其中，a,b,c,d为常量。</p><p>可以得出结论为：</p><ol><li>如果$a=b^d$, 则为$O(n^d\times logn)$</li><li>如果$a&lt;b^d$, 则为$O(n^d)$</li><li>如果$a&gt;b^d$, 则为$O(n^{log_ba})$</li></ol><p>如果你觉得这还是太复杂，你可以运用下面的简单计算方法（可解决大部分问题）：</p><ol><li>如果$a=b$, 则为$O(n^d\times logn)$</li><li>如果$a&lt;b$, 则为$O(n^d)$</li><li>如果$a&gt;b$, 则为$O(n^{log_ba})$</li></ol><p>而CCF最常考的是1.与2.这两种情况。</p><p>网上有相关的参考资料：</p><p><a href="http://ddrv.cn/a/70348">资料</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>NOIp初赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2020/10/08/%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/10/08/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="网站引入"><a href="#网站引入" class="headerlink" title="网站引入"></a>网站引入</h3><p>首先，向大家推荐一个<a href="https://visualgo.net/zh">网站</a>，但是，建议先不要点这个链接，因为这是网站的总版。</p><p>我们需要的排序，应该点击<a href="https://visualgo.net/zh/sorting">这个链接</a>。</p><p>在这里，你可以浏览各种排序方法的动画模拟，让你更加清楚地了解这些排序地具体过程。如果你不想浏览，这里也给出了清楚的总结，请往下看：</p><h3 id="排序的方法"><a href="#排序的方法" class="headerlink" title="排序的方法"></a>排序的方法</h3><p>在这里，将列举各种排序的工作原理。</p><p><strong>冒泡排序</strong>：</p><p>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p><p><strong>选择排序</strong>：</p><p>第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。</p><p><strong>插入排序</strong>：</p><p>将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p><p><strong>归并排序</strong>：</p><p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p><strong>快速排序</strong>：</p><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p><strong>希尔排序</strong>：</p><p>把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</p><h3 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h3><p>这几种排序的方法是否稳定？</p><table><thead><tr><th align="left">算法</th><th align="left">稳定性</th></tr></thead><tbody><tr><td align="left">冒泡排序</td><td align="left">稳定</td></tr><tr><td align="left">选择排序</td><td align="left">不稳定</td></tr><tr><td align="left">插入排序</td><td align="left">稳定</td></tr><tr><td align="left">归并排序</td><td align="left">稳定</td></tr><tr><td align="left">快速排序</td><td align="left">不稳定</td></tr><tr><td align="left">希尔排序</td><td align="left">不稳定</td></tr></tbody></table><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>这几种算法的复杂度是多少？</p><table><thead><tr><th align="left">算法</th><th align="left">复杂度</th></tr></thead><tbody><tr><td align="left">冒泡排序</td><td align="left">$O(n^2)$</td></tr><tr><td align="left">选择排序</td><td align="left">$O(n^2)$</td></tr><tr><td align="left">插入排序</td><td align="left">$O(n)-O(n^2)$</td></tr><tr><td align="left">归并排序</td><td align="left">$O(nlog_n)$</td></tr><tr><td align="left">快速排序</td><td align="left">$O(nlog_n)$</td></tr><tr><td align="left">希尔排序</td><td align="left">$O(n^{1.3})-O(n^2)$</td></tr></tbody></table><h3 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h3><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1n6o8x1q.png" alt="图片"></p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
    
    
    
    <tags>
      
      <tag>NOIp初赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常考协议汇总</title>
    <link href="/2020/10/08/%E5%B8%B8%E8%80%83%E5%8D%8F%E8%AE%AE%E6%B1%87%E6%80%BB/"/>
    <url>/2020/10/08/%E5%B8%B8%E8%80%83%E5%8D%8F%E8%AE%AE%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="协议汇总"><a href="#协议汇总" class="headerlink" title="协议汇总"></a>协议汇总</h3><table><thead><tr><th align="left">协议名称</th><th align="left">中文名称</th></tr></thead><tbody><tr><td align="left">TCP/IP</td><td align="left">传输控制协议/互联网协议</td></tr><tr><td align="left">SMTP</td><td align="left">简单邮件传输协议</td></tr><tr><td align="left">UDP</td><td align="left">用户数据报协议</td></tr><tr><td align="left">P2P</td><td align="left">互联网金融点对点借贷平台</td></tr><tr><td align="left">FTP</td><td align="left">文件传输协议</td></tr><tr><td align="left">POP3</td><td align="left">邮局协议版本3</td></tr><tr><td align="left">WTO</td><td align="left">世界贸易组织</td></tr><tr><td align="left">IMAP</td><td align="left">交互邮件访问协议</td></tr><tr><td align="left">HTTP</td><td align="left">简单请求-响应协议</td></tr><tr><td align="left">WWW</td><td align="left">环球信息网</td></tr></tbody></table><p>以上是部分重要的计算机协议与容易与其混淆的英文缩写。</p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
    
    
    
    <tags>
      
      <tag>NOIp初赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>度</title>
    <link href="/2020/10/08/%E5%BA%A6/"/>
    <url>/2020/10/08/%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>有这样一个问题：有一棵树$T$，$T$有2个度为2的结点，1个度为3的结点，3个度为4的结点，那么树$T$一共有几个树叶？</p><p>要解决这个问题，我们首先要了解什么是度？</p><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>在图论中，最基础的两种模型：树与图，对于“度”有不同的概念。</p><p>树中结点的度：表示这一个节结点的孩子的数量。</p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3171999446,2039123040&fm=26&gp=0.jpg" alt="图片"></p><p>如图所示，结点6的度为2，因为结点6有两个孩子3与9.</p><p>而对于结点2，它的度为1，因为他只有1个孩子。</p><p>图中结点的度：表示连接该结点线的数量。</p><h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><p>对于一棵树来说，我们发现除没有父结点的结点外，每个结点都与通向它的父亲结点所连通的线一一对应。</p><p>也就是说，在整棵树当中，除了１个结点外，其他结点都与度一一对应，所以不难推出公式：</p><p>$n$=$d[1]+d[2]+d[3]+d[4]+…+d[n]+1$</p><p>其中，$sum$表示的是总的结点数，d[i]表示第i个结点的度。转化为中文即是：</p><p>总结点=度的和+1</p><h3 id="题目结尾"><a href="#题目结尾" class="headerlink" title="题目结尾"></a>题目结尾</h3><p>回到开始的题目：</p><p>有一棵树$T$，$T$有2个度为2的结点，1个度为3的结点，3个度为4的结点，那么树$T$一共有几个树叶？</p><p>解：设一共有$x$个叶子结点。</p><p>可以列出方程：2+1+3+$x$=2* 2+1* 3+3* 4+1</p><p>化简可得：$x$=14</p><p>解得：树$T$一共有14个树叶（叶子结点）。</p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
    
    
    
    <tags>
      
      <tag>NOIp初赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI七层协议</title>
    <link href="/2020/10/08/OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/10/08/OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="模型引入"><a href="#模型引入" class="headerlink" title="模型引入"></a>模型引入</h3><p>七层模型，即OSI。参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。</p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><strong>第一层</strong>：物理层</p><p>建立、维护、断开物理连接。</p><p><strong>第二层</strong>：数据链路层</p><p>建立逻辑连接、进行硬件地址寻址、差错校验等功能。</p><p><strong>第三层</strong>：网络层</p><p>进行逻辑地址寻址，实现不同网络之间的路径选择。</p><p><strong>第四层</strong>：传输层</p><p>定义传输数据的协议端口号，以及流控和差错校验。</p><p><strong>第五层</strong>：会话层</p><p>建立、管理、终止会话。</p><p><strong>第六层</strong>：表示层</p><p>数据的表示、安全、压缩。</p><p><strong>第七层</strong>：应用层</p><p>网络服务与最终用户的一个接口。</p><h3 id="图解模型"><a href="#图解模型" class="headerlink" title="图解模型"></a>图解模型</h3><p><img src="https://bkimg.cdn.bcebos.com/pic/b21bb051f8198618b8f0ae2b40ed2e738ad4e6ee?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5" alt="图片"></p><h3 id="口诀背诵"><a href="#口诀背诵" class="headerlink" title="口诀背诵"></a>口诀背诵</h3><p>IOS的七层协议可以用一句口诀来记忆：</p><p>物 数 网 传 会 表 应</p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
    
    
    
    <tags>
      
      <tag>NOIp初赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡特兰数</title>
    <link href="/2020/10/08/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    <url>/2020/10/08/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h3><p>卡特兰数在网上说卡特兰数是一种组合数学中一种常出现于各种计数问题中的数列，但是卡特兰数其实还有另一种应用：求二叉树的个数。具体请往下看。</p><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p><a href="https://blog.csdn.net/wty__/article/details/12950131?utm_source=blogxgwz2">参考资料</a></p><p>我们先来看这样的一个问题：<br>有一个二叉树$T$，一共有$N$个节点，请问这棵二叉树一共有多少种可能的形态？</p><p>我们可以假设$N$为3，那么这棵二叉树可能有以下五中形态：</p><p><img src="https://img-blog.csdn.net/20131023174829093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3R5X18=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片"></p><p>我们令一个数组$C$，用$C_i$来表示第$i$个卡特兰数，经过枚举很容易得出前4项的卡特兰数，即：</p><p>$C_1=1$</p><p>$C_2=2$</p><p>$C_3=5$</p><p>$C_4=14$</p><p>该数列即被称为卡特兰数。</p><h3 id="正文总结"><a href="#正文总结" class="headerlink" title="正文总结"></a>正文总结</h3><p><a href="https://blog.csdn.net/qiuqchen/article/details/23104385?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">参考资料</a></p><p>我们可以通过前4项卡特兰数总结出卡特兰数的通项公式即为：</p><p>$C_i$=$C^i_{2i}\over i+1$(表达式不是很清楚）</p><p>进而化简为：</p><p>$C_i$=$(2i)!\over n!(n+1)!$</p><h3 id="例题结尾"><a href="#例题结尾" class="headerlink" title="例题结尾"></a>例题结尾</h3><p>问题：用5个节点组成的二叉树共有（___）种。</p><p>解法：这道题可以运用卡特兰数的通项公式快速解决：</p><p>$C_i$=$(2i)!\over i!(i+1)!$</p><p>$i$此时为5，则答案$C_5$即为：$(2*5)!\over 5!(5+1)!$</p><p>化简后的结果为42。</p><p>答案：用5个节点组成的二叉树共有（ 42 ）种。</p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
    
    
    
    <tags>
      
      <tag>NOIp初赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
